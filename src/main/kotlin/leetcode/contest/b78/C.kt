package leetcode.contest.b78

import utils.BitTree
import utils.print
import utils.toGrid

fun main() {
    val s = SolutionC()
    // 822
    s.maximumWhiteTiles(
        "[[3745,3757],[3663,3681],[3593,3605],[3890,3903],[3529,3539],[3684,3686],[3023,3026],[2551,2569],[3776,3789],[3243,3256],[3477,3497],[2650,2654],[2264,2266],[2582,2599],[2846,2863],[2346,2364],[3839,3842],[3926,3935],[2995,3012],[3152,3167],[4133,4134],[4048,4058],[3719,3730],[2498,2510],[2277,2295],[4117,4128],[3043,3054],[3394,3402],[3921,3924],[3500,3514],[2789,2808],[3291,3294],[2873,2881],[2760,2760],[3349,3362],[2888,2899],[3802,3822],[3540,3542],[3128,3142],[2617,2632],[3979,3994],[2780,2781],[3213,3233],[3099,3113],[3646,3651],[3956,3963],[2674,2691],[3860,3873],[3363,3370],[2727,2737],[2453,2471],[4011,4031],[3566,3577],[2705,2707],[3560,3565],[3454,3456],[3655,3660],[4100,4103],[2382,2382],[4032,4033],[2518,2531],[2739,2749],[3067,3079],[4068,4074],[2297,2312],[2489,2490],[2954,2974],[2400,2418],[3271,3272],[3628,3632],[3372,3377],[2920,2940],[3315,3330],[3417,3435],[4146,4156],[2324,2340],[2426,2435],[2373,2376],[3621,3626],[2826,2832],[3937,3949],[3178,3195],[4081,4082],[4092,4098],[3688,3698]]".toGrid(),
        1638
    ).print()
}

class SolutionC {
    fun maximumWhiteTiles(tiles: Array<IntArray>, carpetLen: Int): Int {
        val bit = BitTree(Int.MAX_VALUE / 2)
        tiles.forEach {
            bit.add(it[0], it[1], 1)
        }
        var ans = 0
        tiles.forEach {
            ans = maxOf(ans, bit.query(it[0], it[0] + carpetLen - 1))
        }
        return ans
    }

//    fun maximumWhiteTiles(tiles: Array<IntArray>, carpetLen: Int): Int {
//        tiles.sortBy { it[0] }
//        var cur = 0
//        var ans = 0
//        var j = 0
//        for (i in tiles.indices) {
//            // 当前最右侧为右边界
//            cur += tiles[i][1] - tiles[i][0] + 1
//            // 移动左侧覆盖块
//            while (tiles[j][1] < tiles[i][1] - carpetLen) {
//                cur -= tiles[j][1] - tiles[j][0] + 1
//                j++
//            }
//            // 左侧部分块覆盖不到
//            val tmp = cur - maxOf(0, (tiles[i][1] - carpetLen + 1) - tiles[j][0])
//            ans = maxOf(ans, tmp)
//        }
//        return ans
//    }
}